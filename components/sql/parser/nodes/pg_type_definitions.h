#pragma once
#include <cstddef>
#include <cstdint>

typedef uint32_t Oid;
#define InvalidOid ((Oid) 0)

typedef uint32_t Index;

typedef size_t Size;

#define INT64CONST(x) (x##L)

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef NULL
#define NULL ((void*) 0)
#endif

#ifndef _MSC_VER
#include <assert.h>
#define Assert(a) assert(a);
#define AssertMacro(p) ((void) assert(p))
#else
#define Assert(a) (a);
#define AssertMacro(p) ((void) (p))
#endif

typedef uintptr_t Datum;

// mdxn: pg_config_manual.h
#define NAMEDATALEN 64

// mdxn: c.h
/* msb for char */
#define HIGHBIT (0x80)
#define IS_HIGHBIT_SET(ch) ((unsigned char) (ch) &HIGHBIT)

#if defined(HAVE__BUILTIN_UNREACHABLE) && !defined(USE_ASSERT_CHECKING)
#define pg_unreachable() __builtin_unreachable()
#elif defined(_MSC_VER) && !defined(USE_ASSERT_CHECKING)
#define pg_unreachable() __assume(0)
#else
#define pg_unreachable() abort()
#endif

#define PointerIsValid(pointer) ((const void*) (pointer) != NULL)

// mdxn: elog.h
//#define Insist(assertion) \
//	do {				  \
//		if (!(assertion))										   \
//			elog_internalerror(__FILE__, __LINE__, PG_FUNCNAME_MACRO);	\
//	} while(0)

#define Insist(assertion)                                                                                              \
    do {                                                                                                               \
        if (!(assertion))                                                                                              \
            pg_unreachable();                                                                                          \
    } while (0)

/* Error level codes */
#define DEBUG5                                                                                                         \
    10 /* Debugging messages, in categories of
								 * decreasing detail. */
#define DEBUG4 11
#define DEBUG3 12
#define DEBUG2 13
#define DEBUG1 14 /* used by GUC debug_* variables */
#define LOG                                                                                                            \
    15 /* Server operational messages; sent only to
								 * server log by default. */
#define COMMERROR                                                                                                      \
    16 /* Client communication problems; same as LOG
								 * for server reporting, but never sent to
								 * client. */
// This clashes with INFO("") from catch2
// TODO: figure out what to do with thats
/*
#define INFO                                                                                                           \
    17 /* Messages specifically requested by user (eg
								 * VACUUM VERBOSE output); always sent to
								 * client regardless of client_min_messages,
								 * but by default not sent to server log. */
#define NOTICE                                                                                                         \
    18 /* Helpful messages to users about query
								 * operation; sent to client and server log by
								 * default. */
#define WARNING                                                                                                        \
    19 /* Warnings.  NOTICE is for expected messages
								 * like implicit sequence creation by SERIAL.
								 * WARNING is for unexpected messages. */
#define ERROR                                                                                                          \
    20 /* user error - abort transaction; return to
								 * known state */
/* Save ERROR value in PGERROR so it can be restored when Win32 includes
 * modify it.  We have to use a constant rather than ERROR because macros
 * are expanded only when referenced outside macros.
 */
#ifdef WIN32
#define PGERROR 20
#endif
#define FATAL 21 /* fatal error - abort process */
#define PANIC 22 /* take down the other backends with me */

// mdxn: errors generated by postgress src/backend/utils/errcodes.txt
#define ERRCODE_WINDOWING_ERROR 24
#define ERRCODE_SYNTAX_ERROR 25
#define ERRCODE_FEATURE_NOT_SUPPORTED 26
#define ERRCODE_INVALID_PARAMETER_VALUE 27
#define ERRCODE_DUPLICATE_COLUMN 28
#define ERRCODE_INVALID_TABLE_DEFINITION 29
#define ERRCODE_INVALID_ESCAPE_SEQUENCE 30
#define ERRCODE_NONSTANDARD_USE_OF_ESCAPE_CHARACTER 31

// mdxn: timestamp.h
#define INTERVAL_MASK(b) (1 << (b))
#define INTERVAL_FULL_RANGE (0x7FFF)

// mdxn: datetime.h
#define RESERV 0
#define MONTH 1
#define YEAR 2
#define DAY 3
#define JULIAN 4
#define TZ 5    /* fixed-offset timezone abbreviation */
#define DTZ 6   /* fixed-offset timezone abbrev, DST */
#define DYNTZ 7 /* dynamic timezone abbreviation */
#define IGNORE_DTF 8
#define AMPM 9
#define HOUR 10
#define MINUTE 11
#define SECOND 12
#define MILLISECOND 13
#define MICROSECOND 14
#define DOY 15
#define DOW 16
#define UNITS 17
#define ADBC 18
/* these are only for relative dates */
#define AGO 19
#define ABS_BEFORE 20
#define ABS_AFTER 21
/* generic fields to help with parsing */
#define ISODATE 22
#define ISOTIME 23
/* these are only for parsing intervals */
#define WEEK 24
#define DECADE 25
#define CENTURY 26
#define MILLENNIUM 27
/* hack for parsing two-word timezone specs "MET DST" etc */
#define DTZMOD 28 /* "DST" as a separate word */
/* reserved for unrecognized string values */
#define UNKNOWN_FIELD 31

// mdxn: pg_class.h

#define RELPERSISTENCE_PERMANENT 'p' /* regular table */
#define RELPERSISTENCE_UNLOGGED 'u'  /* unlogged permanent table */
#define RELPERSISTENCE_TEMP 't'      /* temporary table */

/* default selection for replica identity (primary key or nothing) */
#define REPLICA_IDENTITY_DEFAULT 'd'
/* no replica identity is logged for this relation */
#define REPLICA_IDENTITY_NOTHING 'n'
/* all columns are loged as replica identity */
#define REPLICA_IDENTITY_FULL 'f'
/*
 * an explicitly chosen candidate key's columns are used as identity;
 * will still be set if the index has been dropped, in that case it
 * has the same meaning as 'd'
 */
#define REPLICA_IDENTITY_INDEX 'i'

// mdxn: pg_class.relkind
#define RELKIND_RELATION 'r'       /* ordinary table */
#define RELKIND_INDEX 'i'          /* secondary index */
#define RELKIND_SEQUENCE 'S'       /* sequence object */
#define RELKIND_TOASTVALUE 't'     /* for out-of-line values */
#define RELKIND_VIEW 'v'           /* view */
#define RELKIND_COMPOSITE_TYPE 'c' /* composite type */
#define RELKIND_FOREIGN_TABLE 'f'  /* foreign table */
#define RELKIND_UNCATALOGED 'u'    /* not yet cataloged */
#define RELKIND_MATVIEW 'm'        /* materialized view */
#define RELKIND_AOSEGMENTS 'o'     /* AO segment files and eof's */
#define RELKIND_AOBLOCKDIR 'b'     /* AO block directory */
#define RELKIND_AOVISIMAP 'M'      /* AO visibility map */
#define RELKIND_YEZZEYINDEX 'Y'    /* yezzey external storage map */

#define RELPERSISTENCE_PERMANENT 'p' /* regular table */
#define RELPERSISTENCE_UNLOGGED 'u'  /* unlogged permanent table */
#define RELPERSISTENCE_TEMP 't'      /* temporary table */

// mdxn: trigger.h
#define TRIGGER_FIRES_ON_ORIGIN 'O'
#define TRIGGER_FIRES_ALWAYS 'A'
#define TRIGGER_FIRES_ON_REPLICA 'R'
#define TRIGGER_DISABLED 'D'

//mdxn: pg_trigger.h
#define TRIGGER_TYPE_ROW (1 << 0)
#define TRIGGER_TYPE_BEFORE (1 << 1)
#define TRIGGER_TYPE_INSERT (1 << 2)
#define TRIGGER_TYPE_DELETE (1 << 3)
#define TRIGGER_TYPE_UPDATE (1 << 4)
#define TRIGGER_TYPE_TRUNCATE (1 << 5)
#define TRIGGER_TYPE_INSTEAD (1 << 6)

#define TRIGGER_TYPE_LEVEL_MASK (TRIGGER_TYPE_ROW)
#define TRIGGER_TYPE_STATEMENT 0

/* Note bits within TRIGGER_TYPE_TIMING_MASK aren't adjacent */
#define TRIGGER_TYPE_TIMING_MASK (TRIGGER_TYPE_BEFORE | TRIGGER_TYPE_INSTEAD)
#define TRIGGER_TYPE_AFTER 0

// mdxn: xml.h
typedef enum
{
    XML_STANDALONE_YES,
    XML_STANDALONE_NO,
    XML_STANDALONE_NO_VALUE,
    XML_STANDALONE_OMITTED
} XmlStandaloneType;

// mdxn: index.h
#define DEFAULT_INDEX_TYPE "btree"

// mdxn: lock.h
#define NoLock 0

#define AccessShareLock 1  /* SELECT */
#define RowShareLock 2     /* SELECT FOR UPDATE/FOR SHARE */
#define RowExclusiveLock 3 /* INSERT, UPDATE, DELETE */
#define ShareUpdateExclusiveLock                                                                                       \
    4               /* VACUUM (non-FULL),ANALYZE, CREATE
										 * INDEX CONCURRENTLY */
#define ShareLock 5 /* CREATE INDEX (WITHOUT CONCURRENTLY) */
#define ShareRowExclusiveLock                                                                                          \
    6 /* like EXCLUSIVE MODE, but allows ROW
										 * SHARE */
#define ExclusiveLock                                                                                                  \
    7 /* blocks ROW SHARE/SELECT...FOR
										 * UPDATE */
#define AccessExclusiveLock                                                                                            \
    8 /* ALTER TABLE, DROP TABLE, VACUUM
										 * FULL, and unqualified LOCK TABLE */